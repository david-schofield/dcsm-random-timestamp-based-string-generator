import { randomTBS, timestampFromRandomTBS, generateRandomTBS } from './index.js';
import {
  getTypeOf
} from 'dcsm-type-helper';

describe('Generate a random timestamp based string', () => {
  describe('generate', () => {
    it('should generate a string', () => {
      const result = randomTBS().generate();
      expect(typeof result).toBe('string');
    });

    it('should generate a unique string each time', () => {
      const result1 = randomTBS().generate();
      const result2 = generateRandomTBS();
      expect(result1 === result2).toBe(false);
    });

    it('should generate a string with the correct format', () => {
      const result = randomTBS().generate();
      expect(/^[B-Za-z]+A[B-Za-z]{20}$/.test(result)).toBe(true);
    });
  });

  describe('retriveTimestamp', () => {

    const errorMessages = {
      header: 'Invalid generated random timestamp-based string!',
      notString: 'A string is required! Received: ', // + getTypeOf(string)
      pattern: 'The string does not match the required pattern /^[B-Za-z]+A[B-Za-z]+$/ for a random timestamp-based string!',
      base51: 'The base51-encoded timestamp does not match the required pattern /^[B-Za-z]+$/!',
      timestamp: 'The timestamp is invalid! The timestamp should be a positive integer less than or equal to Number.MAX_SAFE_INTEGER!',
      //joinedStaticMessages: [errorMessages.pattern, errorMessages.base51, errorMessages.timestamp].join('/n')
    };
    errorMessages.joinedStaticMessages = [errorMessages.pattern, errorMessages.base51, errorMessages.timestamp].join('\n');

    it('should retrieve the timestamp from a string generated by generateRandomTBS', () => {
      const timestamp = Date.now().valueOf();
      const string = generateRandomTBS();
      const result = timestampFromRandomTBS(string);
      expect(timestamp <= result).toBe(true);
    });

    it('should throw an error if the input is not a string', () => {
      expect(() => {
        timestampFromRandomTBS(1234567890);
      }).toThrow([errorMessages.header, errorMessages.notString + getTypeOf(1234567890), errorMessages.joinedStaticMessages].join('\n'));
    });

    it('should throw an error if the input string does not match the required pattern', () => {
      expect(() => {
        timestampFromRandomTBS('invalid-string');
      }).toThrow([errorMessages.header, errorMessages.pattern, errorMessages.base51].join('\n'));
    });

    it('should throw an error if the base51-encoded timestamp does not match the required pattern', () => {
      expect(() => {
        timestampFromRandomTBS('BAZZAaaaaaa');
      }).toThrow(errorMessages.joinedStaticMessages);
    });

    it('should throw an error if the timestamp is invalid', () => {
      expect(() => {
        timestampFromRandomTBS('BAAAAAAAAAAAAAAAAAAAAAA');
      }).toThrow('The timestamp is invalid! The timestamp should be a positive integer less than or equal to Number.MAX_SAFE_INTEGER!');
    });
  });
});